#Problem link:- https://leetcode.com/problems/minimize-malware-spread/

"""In a network of nodes, each node i is directly connected to another node j if and only 
if graph[i][j] = 1.Some nodes initial are initially infected by malware.  Whenever two 
nodes are directly connected and at least one of those two nodes is infected by malware, 
both nodes will be infected by malware.  This spread of malware will continue until no 
more nodes can be infected in this manner.Suppose M(initial) is the final number of nodes 
infected with malware in the entire network, after the spread of malware stops.We will 
remove one node from the initial list.  Return the node that if removed, would minimize 
M(initial).  If multiple nodes could be removed to minimize M(initial), return such a 
node with the smallest index."""

class Solution(object):
    def minMalwareSpread(self, graph, initial):
        n = len(graph)
        colors = {}
        c = 0
        
        def dfs(node,color):
            colors[node] = color
            for nei,adj in enumerate(graph[node]):
                if adj and nei not in colors:
                    dfs(nei,color)
                    
        for node in range(n):
            if node not in colors:
                dfs(node,c)
                c += 1
        
        size = collections.Counter(colors.values())
        
        color_count = collections.Counter()
        for node in initial:
            color_count[colors[node]] += 1
            
        ans = float('inf')
        for x in initial:
            c = colors[x]
            if color_count[c] == 1:
                if ans == float('inf'):
                    ans = x
                elif size[c] > size[colors[ans]]:
                    ans = x
                elif size[c] == size[colors[ans]] and x < ans:
                    ans = x

        return ans if ans < float('inf') else min(initial)    
        